This section relates to basically how all the other sections (which are general utilities) are actually handled and utilized within the client. I achieved this by directly manipulating and modifying the webassembly, while running my utilities from the other sections as necessary. I created a few key webassembly imports that each have special functionalities within the client. In the status section I will indicate what each does. Also note that there will be some (in the scope of this) undefined values (namely window variables) that are declared within the greater file but are just basic values that are handled for the client to actually work. It's not too hard to figure out but if you just try to run these segments as they are you will get some errors because of that.
Packet handler import - ✅ - This is what actually gets the encrypted packet values, and reverses the xor encryption applied to it to get the encoded packet values, which are then in turn handled by the decoding functionality once a packet is detected as complete. Essentially, all the handling that initializes the parsing of packets and stuff comes from this import.

Sender and analytics blocker - ⚪ - This is the packet sending functionality, this takes in any packets we wish to send from a queue (as constructed by our constructors), and applies them into our hooked webassembly which can effectively do the packet sending process for us. It also includes a method of detecting the "T" packet (header 84), which includes analytics data on the user that is then sent to the developers. It modifies this data with a bunch of "/"s, so the analytics data is effectively blocked. The reason this has a very slight, minor problem is because the packet system I utilized will send encoded packets by replacing any ping packets that were originally going to sent by the client with the modified packet, as there is potential for errors regarding memory that I never fixed up otherwise. This still has almost 0 effect as the ping packet is frequently sent many times a second, but if you have many packets to send there is potentially a very slight but noticeable delay in the packet sending in some cases. Still, we are talking only a few ms so this has almost no effect.

Maze map manager - ✅ - This class manages maze maps. It can parse the maps into grids, and convert things like coordinates into nodes. It also includes a pathfinding method so you can pathfind from maze node to maze node.


